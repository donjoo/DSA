
#  ğŸŒ³ What is a Spanning Tree?
# Imagine you have a graph = nodes + edges.
# A spanning tree is just a way to:
# Connect all the nodes
# Using the minimum number of edges (V-1)
# Without forming any cycle
# ğŸ‘‰ Basically: a tree inside a graph that touches every node.
#     Vertices = {A, B, C}
#     Edges = {A-B, B-C, A-C}

# Now, what can be spanning trees?
# We need V-1 = 2 edges to connect all 3 nodes:
#     Tree 1: {A-B, B-C}
#     Tree 2: {A-C, C-B}
#     Tree 3: {A-B, A-C}
# See? Multiple spanning trees exist.


2. Minimum Spanning Tree (MST)
A Minimum Spanning Tree is a spanning tree with the minimum possible total edge weight.
Used in:
Network design (minimum cable cost).
Transportation (cheapest path connecting cities).




Algorithms to Find MST
Two famous ones:



------------->(a) Kruskalâ€™s Algorithm (Greedy, Union-Find)
Sort all edges by weight.
Pick the smallest edge.
Add it to the MST if it doesnâ€™t form a cycle (use Disjoint Set Union-Find).
Repeat until you have V-1 edges.
Time Complexity: O(E log E) (due to sorting).



------------>(b) Primâ€™s Algorithm (Greedy, Priority Queue)
Start from any node.
At each step, pick the minimum edge that connects a vertex inside MST to one outside.
Keep adding until all vertices are covered.
Time Complexity: O(E log V) with min-heap (priority queue).




ğŸ” Graph Indexing
Graph indexing is about how we store and access data efficiently in a graph.
Because graphs can have millions of nodes and edges, searching without an 
index would be very slow.




1. Vertex-Centric Indexes
Focus on the nodes (vertices).
Each vertex maintains an index of its adjacent edges.
Helps quickly find:
â€œWhat edges are connected to this node?â€
â€œWho are my neighbors?â€
âœ… Use Case:
Social network: â€œFind all friends of Aliceâ€ â†’ Look up vertex Alice, 
index directly gives all connected edges (friendships).





2. Edge-Centric Indexes
Focus on the edges themselves.
Each edge can store information to allow fast traversal in both directions.
Helps quickly find:
â€œWhatâ€™s the reverse edge?â€
â€œWhat edge properties exist between nodes?â€
âœ… Use Case
Road network: â€œWhatâ€™s the shortest road between City A and City B?â€ â†’ Look
 up edges by weight/distance.

 | Aspect           | Vertex-Centric                                             | Edge-Centric                                                        |
| ---------------- | ---------------------------------------------------------- | ------------------------------------------------------------------- |
| **Focus**        | Nodes                                                      | Edges                                                               |
| **Index stores** | List of outgoing/incoming edges per vertex                 | References to connected vertices per edge                           |
| **Good for**     | Neighbor queries (friends of a person, links of a webpage) | Path queries, edge properties (shortest road, strongest connection) |
| **Example**      | Facebook friend list                                       | Road distance between cities                                        |





ğŸ“Œ Types of Graphs

1. Unidirectional (Directed Graph / Digraph)
Edges have a direction (one-way).
Example: Twitter follows â†’ A â†’ B means A follows B, but B may not follow A.


2. Bidirectional (Undirected Graph)
Edges donâ€™t have direction (two-way).
Example: Facebook friends â†’ if A is friend with B, then B is also friend with A.



3. Cyclic Graph
A graph that contains at least one cycle (path where you can start and 
come back to the same node).



4. Disconnected Graph
Not all vertices are connected â†’ some nodes cannot be reached from others.


5. Weighted Graph
Each edge has a weight/cost/value.
Example: Road map where edges = roads, weight = distance.


6. Unweighted Graph
All edges are equal (no weight).
Example: Friendships â†’ no cost, just connection.



7. Bipartite Graph
Vertices can be divided into two disjoint sets such that:
Every edge connects a vertex in Set1 to a vertex in Set2.
No edge exists within the same set.
Example: Job matching â†’ People â†” Jobs.















ğŸª™ What is the Greedy Method?
The Greedy Method is an algorithmic strategy where:
ğŸ‘‰ At each step, you make the locally optimal choice (best-looking choice right now), 
hoping it leads to a global optimum.
Always pick what looks best at the moment.
No backtracking
Works only when the problem has the Greedy-choice property (local choice = global optimum).
ğŸ¯ Properties for Greedy to Work
Greedy-choice property â†’ A global optimal solution can be reached by 
choosing local optimums.
Optimal substructure â†’ Problem can be broken into smaller subproblems whose 
solutions can combine to form the overall optimal solution.




ğŸŒ² Kruskalâ€™s Algorithm

Itâ€™s a Greedy Algorithm used to find the Minimum Spanning Tree (MST) of a graph.
ğŸ§© How Kruskalâ€™s Works
Kruskalâ€™s is edge-centric (works with edges, not vertices).
Steps:
Sort all edges by increasing weight.
Pick the smallest edge.
If adding it forms a cycle â†’ skip it.
Otherwise, include it in the MST.
Repeat until you have (V-1) edges (where V = number of vertices).
âœ… Why Greedy?
Because at each step, Kruskal chooses the smallest edge available 
(local optimum) and still guarantees a global optimum MST.





ğŸŒ² Primâ€™s Algorithm
Primâ€™s is also a Greedy Algorithm for MST â€” but unlike Kruskal (edge-based), Primâ€™s is 
vertex-based.
ğŸ§© How Primâ€™s Works
Start from any vertex.
At each step, choose the minimum weight edge that connects a vertex inside the MST to a 
vertex outside the MST.
Repeat until all vertices are included.
Using Adjacency Matrix + simple search â†’ O(VÂ²)
Using Adjacency List + Min Heap (Priority Queue) â†’ O(E log V)


| Feature        | Kruskal                                    | Prim                                    |
| -------------- | ------------------------------------------ | --------------------------------------- |
| Strategy       | **Edge-based** (sort edges, pick smallest) | **Vertex-based** (expand from a vertex) |
| DS Needed      | Union-Find (DSU)                           | Priority Queue (Min-Heap)               |
| Works best     | Sparse graphs (few edges)                  | Dense graphs (many edges)               |
| Starting point | Doesnâ€™t matter                             | Must choose a start vertex              |




ğŸš– Dijkstraâ€™s Algorithm
Itâ€™s a Greedy Algorithm used to find the shortest path from a single source 
vertex to all other vertices in a weighted graph (non-negative weights only âœ…).

ğŸ§© Idea
Start at the source vertex.
Keep track of the minimum distance to each vertex.
Repeatedly pick the vertex with the smallest distance that hasnâ€™t been finalized yet.
Update distances to its neighbors if a shorter path is found.
Repeat until all vertices are processed.



ğŸ” Bellmanâ€“Ford Algorithm
Itâ€™s a Shortest Path Algorithm like Dijkstra, but more powerful because it works 
with graphs that may have negative edge weights (as long as there are no negative
 weight cycles).
ğŸ§© Idea
Dijkstra is greedy â†’ always picks the smallest distance seen so far.
Bellman-Ford uses relaxation:
Keep relaxing all edges V-1 times (where V = number of vertices).
Why V-1? Because the longest shortest path in a graph can have at most (V-1) edges.
Finally, run 1 more iteration:
If any edge can still be relaxed â†’ thereâ€™s a negative weight cycle.




ğŸ“š Topological Sorting (Topo Sort)
ğŸ§© Definition
Topological sort is a linear ordering of vertices in a Directed Acyclic Graph (DAG) such that:
ğŸ‘‰ For every directed edge (u â†’ v), vertex u comes before v in the ordering.
âš ï¸ Key Rules
Only defined for Directed Acyclic Graphs (DAGs).
If thereâ€™s a cycle, no topo order exists.
A DAG can have multiple valid topological orders.




ğŸŒ Floydâ€“Warshall Algorithm
ğŸ§© Definition
The Floydâ€“Warshall Algorithm is a Dynamic Programming algorithm used to find 
shortest paths between all pairs of vertices in a weighted graph (can handle 
negative weights but not negative cycles).
ğŸ“š Idea

Let dist[i][j] = shortest distance from vertex i to j.
Initially:
dist[i][j] = weight(i,j) if thereâ€™s an edge
dist[i][j] = âˆ if no edge
dist[i][i] = 0
Then we try to improve dist[i][j] by allowing intermediate vertices: